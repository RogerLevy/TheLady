\ create varypos 0 , 0 ,

create layoutfile 256 /allot


create temp 256 allot

: fullpath
   z$ 256 temp 0 GetFullPathName  temp swap default.ext ;

: load-layout  ( addr c -- )
   $fload ;
   
: parse-layout  ( addr c -- )
   clean load-layout  last @ name> execute ;


: conform   x @ z @ p* x ! ;  

: layoutfile!   2dup report" Current layout: " -path -ext type layoutfile place ;

: [layout  ( -- <name> ) ( -- )  \ x|. , y|. , prototype , xt ,  ... $DEADBEEF
   create including string,
   does>
      dup count layoutfile! count +
      a!>
      begin @+ dup $DEADBEEF <> while
         @+ 2?p at  @+ @+ swap setoff{ ( conform ) }
      repeat drop ;


: layout]   $DEADBEEF , ;

: flipme  1 flip ! ;

[[ flipme ]] constant f..

\ Layout property tools

\ [ ] "custom" data

%actor reopen
   0 0 action saveprops
endp

\ [x] open access to innards of given prototype
\ [x] needs to compile code into the dictionary

: :props
   here cell- cell- @ dup  innards here 0 , :noname drop [char] ; parse 1 + evaluate here swap !
                           -innards ;

: loadprops
   @+ \ get the address that lets us jump to after the code
   2 +a \ skip the $FF00 of the code
   a@ call
   a!
;


: $[   [char] ] parse postpone (S") ," ;
: space$+    "  " $+ ;

: word,   postpone (s") bl string ;

\ ~> %scissors  ...
\ :: saveprops    savext: dest   savea: flavor ;
\    will generate...
\ x , y , %scissors , ' loadprops ,  ['] n dest ! ATTACKY flavor ! $[ secret message!] idunno place ;

: internal>   enttype @ innards r> call enttype @ -innards ;

: (save$)   " $[ " 2swap $+ $+ " ] " $+ $+ "  place " $+ ;
: (savext)  internal> " ['] " $+  2dup evaluate @ >name count $+ space$+ $+ "  ! " $+ ;
: (savea)   internal> 2dup evaluate @ body> >name count $+ space$+ $+ "  ! " $+ ;
: (savei)   internal> 2dup evaluate @ (.) $+ space$+ $+ "  ! " $+ ;
: (savep)   internal> 2dup evaluate @ p>f 5 (f.) $+ space$+ $+ "  ! " $+ ;
: (savef)   internal> 2dup evaluate f@ 5 (f.) $+ space$+ $+ "  f! " $+ ;
: (savesf)  internal> 2dup evaluate sf@ 5 (f.) $+ space$+ $+ "  sf! " $+ ;

: save$:   ( addr c -- <prop> )   word, postpone (save$) ; immediate
: savext:  ( <prop> )   word, postpone (savext) ; immediate
\ contents of given property must be a named address!
: savea:   ( <prop> )   word, postpone (savea) ; immediate
: savei:   ( <prop> )   word, postpone (savei) ; immediate
: savep:   ( <prop> )   word, postpone (savep) ; immediate
: savef:   ( <prop> )   word, postpone (savef) ; immediate
: savesf:  ( <prop> )   word, postpone (savesf) ; immediate

: xt?   @ >name count type ;


\ store more properties and any type-specific stuff in an agnostic way.
\ the code generated by this word must at least compile an XT, any other data is optional.
defer objprops$+   ' .. is objprops$+

: save-entities ( ... n -- ) 
   layoutfile count w/o create-file throw locals| #1 |
   " [layout " <$ layoutfile count -ext -path $+ $> #1 write-line throw
   [[ {
      x @ 1i (.) <$ "  , " $+
      y @ 1i (.) $+ "  , " $+
      enttype$ $+ "  , " $+
      objprops$+ 
      $> #1 write-line throw
   } ]] execs
   " layout]" #1 write-line throw
   #1 close-file drop ;

: save-stage 
   [[ editable @ ]] which save-entities ;
   
